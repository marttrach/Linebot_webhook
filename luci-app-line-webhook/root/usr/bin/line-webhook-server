#!/usr/bin/env python3
# LINE Webhook Server for OpenWrt
# Reads configuration from UCI and handles LINE BOT messages

import json
import hashlib
import hmac
import base64
import subprocess
import logging
from flask import Flask, request, abort

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

def get_uci_config(option, default=''):
    """Read configuration from UCI."""
    try:
        result = subprocess.run(
            ['uci', 'get', f'line_webhook.main.{option}'],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception as e:
        logger.error(f"Failed to read UCI config {option}: {e}")
    return default

def validate_signature(body, signature, channel_secret):
    """Validate LINE webhook signature."""
    hash_value = hmac.new(
        channel_secret.encode('utf-8'),
        body.encode('utf-8'),
        hashlib.sha256
    ).digest()
    calculated_signature = base64.b64encode(hash_value).decode('utf-8')
    return hmac.compare_digest(signature, calculated_signature)

def send_reply(reply_token, messages, access_token):
    """Send reply message via LINE API."""
    import requests
    
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}'
    }
    
    data = {
        'replyToken': reply_token,
        'messages': messages
    }
    
    try:
        response = requests.post(
            'https://api.line.me/v2/bot/message/reply',
            headers=headers,
            json=data,
            timeout=10
        )
        response.raise_for_status()
        logger.info("Reply sent successfully")
        return True
    except Exception as e:
        logger.error(f"Failed to send reply: {e}")
        return False

def process_message(event, access_token):
    """
    Process incoming message and generate reply.
    This function can be extended for custom logic.
    """
    message_type = event.get('message', {}).get('type', '')
    reply_token = event.get('replyToken', '')
    
    if not reply_token:
        return
    
    if message_type == 'text':
        text = event['message'].get('text', '')
        # Default: Echo the message
        # TODO: Extend here for custom reply logic
        reply_text = text
        messages = [{'type': 'text', 'text': reply_text}]
    else:
        messages = [{'type': 'text', 'text': '你傳的不是文字訊息喔～'}]
    
    send_reply(reply_token, messages, access_token)

@app.route('/', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return 'LINE Webhook Server is running', 200

@app.route('/', methods=['POST'])
def webhook():
    """Handle LINE webhook events."""
    # Get configuration
    access_token = get_uci_config('access_token')
    channel_secret = get_uci_config('channel_secret')
    
    if not access_token or not channel_secret:
        logger.error("Missing access_token or channel_secret in configuration")
        abort(500)
    
    # Get request body and signature
    body = request.get_data(as_text=True)
    signature = request.headers.get('X-Line-Signature', '')
    
    # Validate signature
    if not validate_signature(body, signature, channel_secret):
        logger.warning("Invalid signature")
        abort(403)
    
    # Parse and process events
    try:
        data = json.loads(body)
        events = data.get('events', [])
        
        for event in events:
            event_type = event.get('type', '')
            logger.info(f"Received event: {event_type}")
            
            if event_type == 'message':
                process_message(event, access_token)
            # TODO: Handle other event types (follow, unfollow, join, etc.)
            
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON: {e}")
        abort(400)
    except Exception as e:
        logger.error(f"Error processing webhook: {e}")
    
    return 'OK'

def main():
    """Main entry point."""
    port = int(get_uci_config('port', '5000'))
    bind_address = get_uci_config('bind_address', '0.0.0.0')
    
    logger.info(f"Starting LINE Webhook Server on {bind_address}:{port}")
    app.run(host=bind_address, port=port, threaded=True)

if __name__ == '__main__':
    main()
